:root {
  /* The size of the squares in the Othello board.  Many other things are
   * computed relative to this size, which will change in certain screen
   * layouts and sizes. */
  --square-size: 2em;
}

/* ===============
 * The game board.
 * =============== */

.gameBoardContainer{
    display: flex;
}

.gameBoard {
  /* The game board is an 8x8 grid. */
  display: grid;
  grid-template: repeat(10, 1fr) / repeat(10, 1fr);

  /* The border around the whole board. */
  border: 1px solid black;

  /* The .spot elements will be positioned absolutely within this board. */
  position: relative;
}

/* Any container that holds a stone, including a square in the board. */
.stone-container {
  width: var(--square-size);
  height: var(--square-size);

  /* For the score board stones, we need to make sure the size of the container
   * is properly constrained.  Otherwise, display: inline would make the SVG
   * inside blow up and escape the width & height above. */
  display: inline-flex;
  justify-content: center;
  align-items: center;

  /* The score board stones have text overlayed with absolute positioning. */
  position: relative;
}

.square {
  /* The squares are all green with a black border. */
  background-color: green;
  border: 1px solid black;

  /* The size of the squares should include the border, or else the overall
   * board might be too big. */
  box-sizing: border-box;

  /* Fixes minor positioning weirdness for svg at zoom */
  line-height: 0;
}

/* Any container that holds a stone, including a square in the board. */
.reference-container {
  width: var(--square-size);
  height: var(--square-size);

  /* For the score board stones, we need to make sure the size of the container
   * is properly constrained.  Otherwise, display: inline would make the SVG
   * inside blow up and escape the width & height above. */
  display: inline-flex;
  justify-content: center;
  align-items: center;

  /* The score board stones have text overlayed with absolute positioning. */
  position: relative;
}

.boardBorder {
  /* The squares are all green with a black border. */
  background-color: brown;
  border: 0px;

  /* The size of the squares should include the border, or else the overall
   * board might be too big. */
  box-sizing: border-box;

  /* Fixes minor positioning weirdness for svg at zoom */
  line-height: 0;
}

.spot {
  /* A "dot" at the corners of certain parts of the board.  This base class
   * contains everything but the actual positions. */
  position: absolute;
  width: .5em;
  height: .5em;
  border-radius: 50%;
  background-color: black;
}

/* The positions of specific spots. */
#spot-0 {
  left: calc(var(--square-size) * 3 - .25em);
  top: calc(var(--square-size) * 3 - .25em);
}
#spot-1 {
  left: calc(var(--square-size) * 7 - .25em);
  top: calc(var(--square-size) * 3 - .25em);
}
#spot-2 {
  left: calc(var(--square-size) * 3 - .25em);
  top: calc(var(--square-size) * 7 - .25em);
}
#spot-3 {
  left: calc(var(--square-size) * 7 - .25em);
  top: calc(var(--square-size) * 7 - .25em);
}

/* ======================
 * The stones themselves.
 * ====================== */

svg {
  /* The SVG should scale according to its container. */
  width: 100%;
  height: 100%;
}

/* The circle within the SVG. */
.stone {
  /* When we use transform to animate it, do it relative to the center. */
  transform-origin: 50% 50%;

  /* Empty by default.  Game board squares all contain an SVG for a stone, but
   * you just won't see it until we give the container a color class. */
  fill: none;
  stroke: none;
  stroke-width: 1px;  /* In SVG coordinates, not page coordinates. */
}

.black .stone {
  fill: black;
  stroke: white;
}

.white .stone {
  fill: white;
  stroke: black;
}

/* When we flip a stone, we use the .flip class temporarily to animate the
 * change. There are separate animations for black & white because you can't
 * use CSS filters to change the stroke and fill colors in an SVG. */
.black.flip .stone {
  animation: flip-black 1s ease-in-out;
}
.white.flip .stone {
  animation: flip-white 1s ease-in-out;
}

/* Flip from black to white by shrinking horizontally, then expanding back out
 * to full size.  Fade out the stroke along the way to reduce aliasing. */
@keyframes flip-white {
  0% {
    transform: scaleX(1);
    fill: black;
    stroke: white;
  }
  50% {
    transform: scaleX(0);
    fill: black;
    stroke: none;
  }
  50.001% {
    transform: scaleX(0);
    fill: white;
    stroke: none;
  }
  100% {
    transform: scaleX(1);
    fill: white;
    stroke: black;
  }
}

/* The same animation as above, but from white to black. */
@keyframes flip-black {
  0% {
    transform: scaleX(1);
    fill: white;
    stroke: black;
  }
  50% {
    transform: scaleX(0);
    fill: white;
    stroke: none;
  }
  50.001% {
    transform: scaleX(0);
    fill: black;
    stroke: none;
  }
  100% {
    transform: scaleX(1);
    fill: black;
    stroke: white;
  }
}
