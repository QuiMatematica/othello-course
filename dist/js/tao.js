/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/board.js":
/*!*************************!*\
  !*** ./src/js/board.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   animatingFlip: () => (/* binding */ animatingFlip),\n/* harmony export */   createStone: () => (/* binding */ createStone),\n/* harmony export */   \"default\": () => (/* binding */ Board)\n/* harmony export */ });\n/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ \"./src/js/position.js\");\n\r\n\r\n\r\n\r\nlet animatingFlip = false;\r\n\r\nconst xmlns = 'http://www.w3.org/2000/svg';\r\n\r\nfunction createStone() {\r\n    const svg = document.createElementNS(xmlns, 'svg');\r\n    svg.setAttributeNS(null, 'viewBox', '0 0 100 100');\r\n\r\n    // The circle of the stone itself.\r\n    const circle = document.createElementNS(xmlns, 'circle');\r\n    circle.classList.add('stone');\r\n    circle.setAttributeNS(null, 'cx', '50');\r\n    circle.setAttributeNS(null, 'cy', '50');\r\n    circle.setAttributeNS(null, 'r', '45');\r\n    svg.appendChild(circle);\r\n\r\n    return svg;\r\n}\r\n\r\nclass Board {\r\n\r\n    container;\r\n    counter;\r\n    gameBoardContainer;\r\n    gameBoard;\r\n    grid = [];\r\n\r\n    letters = ['', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', '']\r\n\r\n    constructor(container, counter, onClickCallback) {\r\n        this.container = container;\r\n        this.counter = counter;\r\n\r\n        this.gameBoardContainer = document.createElement('div');\r\n        this.gameBoardContainer.classList.add('game-board-container')\r\n        this.container.appendChild(this.gameBoardContainer)\r\n\r\n        this.gameBoard = document.createElement('div');\r\n        this.gameBoard.classList.add('gameBoard');\r\n        this.gameBoardContainer.appendChild(this.gameBoard)\r\n\r\n        this.createBoard(onClickCallback)\r\n    }\r\n\r\n    createBoard(onClickCallback) {\r\n        // Prima riga: riferimenti\r\n        for (let x = 0; x < 10; ++x) {\r\n            const div = document.createElement('div');\r\n            div.classList.add('boardBorder');\r\n            div.classList.add('reference-container');\r\n            div.innerHTML = this.letters[x];\r\n            this.gameBoard.appendChild(div);\r\n        }\r\n\r\n        for (let y = 0; y < 8; ++y) {\r\n            const row = [];\r\n            this.grid.push(row);\r\n\r\n            const firstDiv = document.createElement('div');\r\n            firstDiv.classList.add('boardBorder');\r\n            firstDiv.classList.add('reference-container');\r\n            firstDiv.innerHTML = y + 1;\r\n            this.gameBoard.appendChild(firstDiv);\r\n\r\n            for (let x = 0; x < 8; ++x) {\r\n                // Create a square element.\r\n                const div = document.createElement('div');\r\n                div.classList.add('square');\r\n                div.classList.add('stone-container');\r\n\r\n                // Store the grid coordinates on the element.\r\n                div.dataset.counter = this.counter;\r\n                div.dataset.x = x;\r\n                div.dataset.y = y;\r\n\r\n                // When the square is clicked, invoke this callback.\r\n                div.addEventListener('click', onClickCallback);\r\n\r\n                // When the flip animation ends, update the flip state and mark the valid\r\n                // moves for the next player.\r\n                div.addEventListener('animationend', () => {\r\n                    animatingFlip = false;\r\n                });\r\n\r\n                // Add the stone itself, which will not show up until a black or white\r\n                // class is added to the square.\r\n                div.appendChild(createStone());\r\n\r\n                // Add the square to the DOM and to the 2D array.\r\n                this.gameBoard.appendChild(div);\r\n                row.push(div);\r\n            }\r\n\r\n            const lastDiv = document.createElement('div');\r\n            lastDiv.classList.add('boardBorder');\r\n            lastDiv.classList.add('reference-container');\r\n            lastDiv.innerHTML = y + 1;\r\n            this.gameBoard.appendChild(lastDiv);\r\n        }\r\n\r\n        // Ultima riga: riferimenti\r\n        for (let x = 0; x < 10; ++x) {\r\n            const div = document.createElement('div');\r\n            div.classList.add('boardBorder');\r\n            div.classList.add('reference-container');\r\n            div.innerHTML = this.letters[x];\r\n            this.gameBoard.appendChild(div);\r\n        }\r\n\r\n        // Add the spots on the inner board corners.\r\n        for (let x = 0; x < 4; ++x) {\r\n            const spot = document.createElement('div');\r\n            spot.classList.add('spot');\r\n            spot.id = 'spot-' + x;\r\n            this.gameBoard.appendChild(spot);\r\n        }\r\n    }\r\n\r\n    resetGame() {\r\n        for (const div of this.gameBoard.querySelectorAll('.square')) {\r\n            div.classList.remove('black');\r\n            div.classList.remove('white');\r\n            div.classList.remove('flip');\r\n        }\r\n    }\r\n\r\n    setStone(x, y, color) {\r\n        if (color == _position_js__WEBPACK_IMPORTED_MODULE_0__.WHITE) {\r\n            this.grid[y][x].classList.add('white');\r\n        }\r\n        else if (color == _position_js__WEBPACK_IMPORTED_MODULE_0__.BLACK) {\r\n            this.grid[y][x].classList.add('black');\r\n        }\r\n    }\r\n\r\n    setPosition(position) {\r\n        this.resetGame();\r\n        for (let x = 0; x < 8; x++) {\r\n            for (let y = 0; y < 8; y++) {\r\n                const color = position.grid[y][x];\r\n                if (color == _position_js__WEBPACK_IMPORTED_MODULE_0__.WHITE) {\r\n                    this.grid[y][x].classList.add('white');\r\n                }\r\n                else if (color == _position_js__WEBPACK_IMPORTED_MODULE_0__.BLACK) {\r\n                    this.grid[y][x].classList.add('black');\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    playPosition(position) {\r\n        // Place the stone by adding the relevant color class.\r\n        const playSquare = this.grid[position.played.y][position.played.x];\r\n        playSquare.classList.add(Board.getColor(position.prevPosition.turn));\r\n\r\n        for (const flipped of position.flipped) {\r\n            const div = this.grid[flipped.y][flipped.x];\r\n            div.classList.add('flip');\r\n            div.classList.add(Board.getColor(position.prevPosition.turn));\r\n            div.classList.remove(Board.getColor(-position.prevPosition.turn));\r\n        }\r\n\r\n        // Set this flag to indicate that we're animating the flip now.\r\n        animatingFlip = true;\r\n    }\r\n\r\n    static getColor(positionColor) {\r\n        if (positionColor == _position_js__WEBPACK_IMPORTED_MODULE_0__.WHITE) {\r\n            return 'white';\r\n        }\r\n        else if (positionColor == _position_js__WEBPACK_IMPORTED_MODULE_0__.BLACK) {\r\n            return 'black';\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // Returns the opposite of a player's color.\r\n    static oppositeColor(color) {\r\n        return color == 'white' ? 'black' : 'white';\r\n    }\r\n\r\n    isSquareEmpty(x, y) {\r\n        return Board.isEmpty(this.grid[y][x]);\r\n    }\r\n\r\n    // True if the square is empty.\r\n    static isEmpty(div) {\r\n        return !div.classList.contains('black') && !div.classList.contains('white');\r\n    }\r\n\r\n    // True if the square belongs to that player.\r\n    static isColor(div, color) {\r\n        return div.classList.contains(color);\r\n    }\r\n\r\n    addASquares(add) {\r\n        this.addLetter(0, 3, \"A\");\r\n        this.addLetter(3, 0, \"A\");\r\n        this.addLetter(0, 4, \"A\");\r\n        this.addLetter(3, 7, \"A\");\r\n        this.addLetter(7, 3, \"A\");\r\n        this.addLetter(4, 0, \"A\");\r\n        this.addLetter(7, 4, \"A\");\r\n        this.addLetter(4, 7, \"A\");\r\n    }\r\n\r\n    addBSquares(add) {\r\n        this.addLetter(0, 2, \"B\");\r\n        this.addLetter(2, 0, \"B\");\r\n        this.addLetter(0, 5, \"B\");\r\n        this.addLetter(2, 7, \"B\");\r\n        this.addLetter(7, 2, \"B\");\r\n        this.addLetter(5, 0, \"B\");\r\n        this.addLetter(7, 5, \"B\");\r\n        this.addLetter(5, 7, \"B\");\r\n    }\r\n\r\n    addCSquares(add) {\r\n        this.addLetter(0, 1, \"C\");\r\n        this.addLetter(1, 0, \"C\");\r\n        this.addLetter(0, 6, \"C\");\r\n        this.addLetter(1, 7, \"C\");\r\n        this.addLetter(7, 1, \"C\");\r\n        this.addLetter(6, 0, \"C\");\r\n        this.addLetter(7, 6, \"C\");\r\n        this.addLetter(6, 7, \"C\");\r\n    }\r\n\r\n    addXSquares(add) {\r\n        this.addLetter(1, 1, \"X\");\r\n        this.addLetter(1, 6, \"X\");\r\n        this.addLetter(6, 1, \"X\");\r\n        this.addLetter(6, 6, \"X\");\r\n    }\r\n\r\n    addLetter(x, y, letter) {\r\n        const square = this.grid[y][x];\r\n\r\n        const textNode = document.createTextNode(letter); // last/deepest child\r\n\r\n        const textElement = document.createElementNS(xmlns, 'text'); // first/deepest parent\r\n\r\n        if (Board.isColor(square, \"black\")) {\r\n            textElement.setAttributeNS(null, 'fill', 'white');\r\n            textElement.setAttributeNS(null, 'stroke', 'white');\r\n        }\r\n        else {\r\n            textElement.setAttributeNS(null, 'fill', 'black');\r\n            textElement.setAttributeNS(null, 'stroke', 'black');\r\n        }\r\n        textElement.setAttributeNS(null, 'x', '50');\r\n        textElement.setAttributeNS(null, 'y', '55');\r\n        textElement.setAttributeNS(null, 'alignment-baseline', \"middle\");\r\n        textElement.setAttributeNS(null, 'text-anchor', \"middle\");\r\n        if (letter.length == 1) {\r\n            textElement.setAttributeNS(null, 'font-size', 80);\r\n        }\r\n        else {\r\n            textElement.setAttributeNS(null, 'font-size', 60);\r\n        }\r\n        textElement.append(textNode);\r\n        square.firstChild.append(textElement); // append deepest child to first parent\r\n    }\r\n\r\n    removeLetter(x, y) {\r\n        const square = this.grid[y][x];\r\n        square.getElementsByTagName(\"text\").item(0).remove();\r\n    }\r\n\r\n}\r\n\n\n//# sourceURL=webpack:///./src/js/board.js?");

/***/ }),

/***/ "./src/js/othello.js":
/*!***************************!*\
  !*** ./src/js/othello.js ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ \"./src/js/position.js\");\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./board.js */ \"./src/js/board.js\");\n/* harmony import */ var _score_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./score.js */ \"./src/js/score.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst boards = []\r\n\r\nfunction init() {\r\n    document.querySelectorAll('.free-game-board').forEach((item) => {\r\n        const freeGame = new FreeGameBoard(item, boards.length);\r\n        boards.push(freeGame);\r\n    });\r\n    document.querySelectorAll('.match-file-board').forEach((item) => {\r\n        const matchFile = new MatchFileBoard(item, boards.length);\r\n        boards.push(matchFile);\r\n    });\r\n    document.querySelectorAll('.click-on-board').forEach((item) => {\r\n        const clickOn = new ClickOnBoard(item, boards.length);\r\n        boards.push(clickOn);\r\n    });\r\n    document.querySelectorAll('.sequence-board').forEach((item) => {\r\n        const sequence = new SequenceBoard(item, boards.length);\r\n        boards.push(sequence);\r\n    });\r\n    document.querySelectorAll('.referee-board').forEach((item) => {\r\n        const referee = new RefereeBoard(item, boards.length);\r\n        boards.push(referee);\r\n    });\r\n}\r\n\r\nmodule.exports = init;\r\n\r\nfunction staticBoardOnClick(event) {\r\n}\r\n\r\nclass RefereeBoard {\r\n\r\n    board;\r\n    score;\r\n\r\n    constructor(container, counter) {\r\n        const emptyPosition = _position_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStartingPosition();\r\n        this.board = new _board_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](container, counter, staticBoardOnClick);\r\n        this.board.setPosition(emptyPosition);\r\n        this.score = new _score_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](container, this.board);\r\n        this.score.takeScore(emptyPosition);\r\n\r\n        const matchFile = container.dataset['file'];\r\n        let json;\r\n        fetch(matchFile)\r\n            .then((response) => response.json())\r\n            .then((json) => this.readMatch(json));\r\n    }\r\n\r\n    readMatch(json) {\r\n        var position = _position_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStartingPosition();\r\n        const txt = json.txt;\r\n        for (var i = 0; i*2 < txt.length; i++) {\r\n            const s = txt.substring(i*2, i*2 + 2);\r\n            const square = _position_js__WEBPACK_IMPORTED_MODULE_0__.Square.fromString(s);\r\n            this.board.setStone(square.x, square.y, position.turn);\r\n            this.board.addLetter(square.x, square.y, (i + 1).toString());\r\n            position = position.playStone(square);\r\n        }\r\n        this.score.takeScore(position);\r\n    }\r\n\r\n}\r\n\r\nclass SequenceBoard {\r\n\r\n    currentPosition;\r\n    board;\r\n    score;\r\n    controls;\r\n    comment;\r\n    humanColor;\r\n\r\n    constructor(container, counter) {\r\n        this.currentPosition = _position_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getEmptyPosition();\r\n        this.board = new _board_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](container, counter, sequenceBoardOnClick);\r\n        this.board.setPosition(this.currentPosition);\r\n        this.score = new _score_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](container, this.board);\r\n        this.score.takeScore(this.currentPosition);\r\n        this.controls = new SequenceControls(container, counter);\r\n        this.comment = new PositionComment(container);\r\n\r\n        const matchFile = container.dataset['file'];\r\n        let json;\r\n        fetch(matchFile)\r\n            .then((response) => response.json())\r\n            .then((json) => this.readMatch(json));\r\n    }\r\n\r\n    readMatch(json) {\r\n        this.currentPosition = _position_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getPositionFromJSON(json);\r\n        this.currentPosition.comment = json.comment;\r\n        this.humanColor = this.currentPosition.turn;\r\n        var curPosition = this.currentPosition;\r\n\r\n        json.moves.forEach((move) => {\r\n            const square = _position_js__WEBPACK_IMPORTED_MODULE_0__.Square.fromString(move.move);\r\n            curPosition = curPosition.playStone(square);\r\n            curPosition.comment = move.comment;\r\n        });\r\n        if (json.moves.length < 2) {\r\n            this.controls.prev.remove();\r\n            this.controls.computer.remove();\r\n        }\r\n\r\n        this.board.setPosition(this.currentPosition);\r\n        this.score.takeScore(this.currentPosition);\r\n        this.controls.update(this.currentPosition, this.humanColor);\r\n        this.comment.setPositionComment(this.currentPosition);\r\n    }\r\n\r\n    moveComputer() {\r\n        const nextPosition = this.currentPosition.nextPosition;\r\n        if (nextPosition != null) {\r\n            this.board.playPosition(nextPosition);\r\n            this.score.takeScore(nextPosition);\r\n             if (nextPosition.nextPosition == null && nextPosition.comment == null) {\r\n                this.comment.setComment(\"<span class=\\\"fw-bold\\\">Sequenza terminata.</span>\");\r\n            }\r\n            else {\r\n                this.comment.setPositionComment(nextPosition);\r\n            }\r\n            this.controls.update(nextPosition, this.humanColor);\r\n            this.currentPosition = nextPosition;\r\n        }\r\n    }\r\n\r\n    moveHuman(square) {\r\n        if (this.currentPosition.turn === this.humanColor) {\r\n            const expected = this.currentPosition.nextPosition.played;\r\n            if (square.x === expected.x && square.y === expected.y) {\r\n                const nextPosition = this.currentPosition.nextPosition;\r\n                this.board.playPosition(nextPosition);\r\n                this.score.takeScore(nextPosition);\r\n                if (nextPosition.nextPosition == null && nextPosition.comment == null) {\r\n                    this.comment.setComment(\"<span class=\\\"fw-bold\\\">Sequenza terminata.</span>\");\r\n                }\r\n                else {\r\n                    this.comment.setPositionComment(nextPosition);\r\n                }\r\n                this.controls.update(nextPosition, this.humanColor);\r\n                this.currentPosition = nextPosition;\r\n            }\r\n            else {\r\n                const correctPosition = this.currentPosition.nextPosition;\r\n                const wrongPosition = this.currentPosition.playStone(square);\r\n                this.board.playPosition(wrongPosition);\r\n                this.score.takeScore(wrongPosition);\r\n                this.controls.wrong();\r\n                this.comment.setComment(\"<span class=\\\"text-danger fw-bold\\\">Mossa errata.</span>\");\r\n                this.currentPosition.nextPosition = correctPosition;\r\n                this.currentPosition = wrongPosition;\r\n            }\r\n        }\r\n    }\r\n\r\n    goToPreviousPosition() {\r\n        const prevPosition = this.currentPosition.prevPosition;\r\n        if (prevPosition != null) {\r\n            this.board.setPosition(prevPosition);\r\n            this.score.takeScore(prevPosition);\r\n            this.comment.setPositionComment(prevPosition);\r\n            this.controls.update(prevPosition, this.humanColor);\r\n            this.currentPosition = prevPosition;\r\n        }\r\n    }\r\n\r\n    goToFirstPosition() {\r\n        var curPosition = this.currentPosition;\r\n        var prevPosition = curPosition.prevPosition;\r\n        if (prevPosition != null) {\r\n            while (prevPosition != null) {\r\n                curPosition = prevPosition;\r\n                prevPosition = curPosition.prevPosition;\r\n            }\r\n            this.board.setPosition(curPosition);\r\n            this.score.takeScore(curPosition);\r\n            this.comment.setPositionComment(curPosition);\r\n            this.controls.update(curPosition, this.humanColor);\r\n            this.currentPosition = curPosition;\r\n        }\r\n    }\r\n\r\n}\r\n\r\nclass SequenceControls {\r\n\r\n    buttonsContainer;\r\n    first;\r\n    prev;\r\n    computer;\r\n\r\n    constructor(container, counter) {\r\n        this.first = document.createElement(\"button\");\r\n        this.first.classList.add(\"btn\");\r\n        this.first.classList.add(\"btn-primary\");\r\n        this.first.dataset.counter = counter;\r\n        this.first.appendChild(document.createTextNode(\"|<\"));\r\n        this.first.addEventListener('click', sequenceOnFirstClick);\r\n\r\n        this.prev = document.createElement(\"button\");\r\n        this.prev.classList.add(\"btn\");\r\n        this.prev.classList.add(\"btn-primary\");\r\n        this.prev.dataset.counter = counter;\r\n        this.prev.appendChild(document.createTextNode(\"<\"));\r\n        this.prev.addEventListener('click', sequenceOnPrevClick);\r\n\r\n        this.computer = document.createElement(\"button\");\r\n        this.computer.classList.add(\"btn\");\r\n        this.computer.classList.add(\"btn-primary\");\r\n        this.computer.dataset.counter = counter;\r\n        this.computer.appendChild(document.createTextNode(\"Muove il computer\"));\r\n        this.computer.addEventListener('click', sequenceOnComputerClick);\r\n\r\n        const buttonGroup = document.createElement(\"div\");\r\n        buttonGroup.classList.add(\"btn-group\");\r\n        buttonGroup.classList.add(\"btn-group-sm\");\r\n        buttonGroup.setAttribute(\"role\", \"group\");\r\n        buttonGroup.setAttribute(\"aria-label\", \"Gruppo di controlli\");\r\n        buttonGroup.appendChild(this.first);\r\n        buttonGroup.appendChild(this.prev);\r\n        buttonGroup.appendChild(this.computer);\r\n\r\n        this.buttonsContainer = document.createElement(\"div\");\r\n        this.buttonsContainer.classList.add(\"text-center\");\r\n        this.buttonsContainer.appendChild(buttonGroup);\r\n\r\n        container.appendChild(this.buttonsContainer);\r\n    }\r\n\r\n    update(position, humanColor) {\r\n        this.first.disabled = (position.prevPosition == null);\r\n        this.prev.disabled = (position.prevPosition == null);\r\n        this.computer.disabled = (position.nextPosition == null || position.turn == humanColor);\r\n    }\r\n\r\n    wrong(position, humanColor) {\r\n        this.first.disabled = false;\r\n        this.prev.disabled = false;\r\n        this.computer.disabled = true;\r\n    }\r\n\r\n}\r\n\r\nfunction sequenceOnFirstClick(event) {\r\n    const div = event.currentTarget;\r\n    const counter = div.dataset.counter;\r\n    const sequenceBoard = boards[counter];\r\n    sequenceBoard.goToFirstPosition();\r\n}\r\n\r\nfunction sequenceOnPrevClick(event) {\r\n    const div = event.currentTarget;\r\n    const counter = div.dataset.counter;\r\n    const sequenceBoard = boards[counter];\r\n    sequenceBoard.goToPreviousPosition();\r\n}\r\n\r\nfunction sequenceOnComputerClick(event) {\r\n    const div = event.currentTarget;\r\n    const counter = div.dataset.counter;\r\n    const sequenceBoard = boards[counter];\r\n    sequenceBoard.moveComputer();\r\n}\r\n\r\nfunction sequenceBoardOnClick(event) {\r\n    // Ignore if we're still animating the last move.\r\n    if (_board_js__WEBPACK_IMPORTED_MODULE_1__.animatingFlip) {\r\n        return;\r\n    }\r\n\r\n    // Find the coordinates of the clicked square.\r\n    const div = event.currentTarget;\r\n    const {counter, x, y} = div.dataset;  // NOTE: strings, not ints\r\n    const sequenceBoard = boards[counter];\r\n    const square = new _position_js__WEBPACK_IMPORTED_MODULE_0__.Square(parseInt(x), parseInt(y));\r\n    sequenceBoard.moveHuman(square);\r\n}\r\n\r\nclass ClickOnBoard {\r\n\r\n    container;\r\n    counter;\r\n\r\n    position;\r\n    board;\r\n    comment;\r\n    controls;\r\n\r\n    correct;\r\n    correctCount;\r\n    clicked;\r\n\r\n    constructor(container, counter) {\r\n        this.currentPosition = _position_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getEmptyPosition();\r\n        this.board = new _board_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](container, counter, clickOnClick);\r\n        this.board.setPosition(this.currentPosition);\r\n        this.comment = new PositionComment(container);\r\n        this.controls = new ClickOnControls(container, counter);\r\n\r\n        this.correct = [];\r\n        this.clicked = [];\r\n        this.correctCount = 0;\r\n\r\n        const matchFile = container.dataset['file'];\r\n        let json;\r\n        fetch(matchFile)\r\n            .then((response) => response.json())\r\n            .then((json) => this.readMatch(json));\r\n    }\r\n\r\n    readMatch(json) {\r\n        this.currentPosition = _position_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getPositionFromJSON(json);\r\n        this.board.setPosition(this.currentPosition);\r\n\r\n        json.correct.forEach((notation) => {\r\n            const square = _position_js__WEBPACK_IMPORTED_MODULE_0__.Square.fromString(notation);\r\n            this.correct.push(square);\r\n        })\r\n\r\n        this.updateComment();\r\n        this.controls.reset.disabled = true;\r\n    }\r\n\r\n    checkClick(square) {\r\n        if (this.clicked.findIndex(c => (c.x == square.x && c.y == square.y)) == -1) {\r\n            const squareIndex = this.correct.findIndex(c => (c.x == square.x && c.y == square.y));\r\n            if (squareIndex > -1) {\r\n                this.board.addLetter(square.x, square.y, String.fromCharCode(10003));\r\n                this.correctCount++;\r\n                this.updateComment();\r\n            }\r\n            else {\r\n                this.board.addLetter(square.x, square.y, String.fromCharCode(10007));\r\n            }\r\n            this.clicked.push(square);\r\n            this.controls.reset.disabled = false;\r\n        }\r\n    }\r\n\r\n    reset() {\r\n        this.clicked.forEach((square) => {\r\n            this.board.removeLetter(square.x, square.y);\r\n        });\r\n        this.updateComment();\r\n        this.clicked = [];\r\n        this.correctCount = 0;\r\n        this.controls.reset.disabled = true;\r\n    }\r\n\r\n    updateComment() {\r\n        const cmd = \"Risposte corrette: \" + this.correctCount + \"<br>Risposte attese: \" + this.correct.length;\r\n        this.comment.setComment(cmd);\r\n    }\r\n\r\n}\r\n\r\nfunction clickOnClick(event) {\r\n    // Find the coordinates of the clicked square.\r\n    const div = event.currentTarget;\r\n    const {counter, x, y} = div.dataset;  // NOTE: strings, not ints\r\n    const clickOnBoard = boards[counter];\r\n    const square = new _position_js__WEBPACK_IMPORTED_MODULE_0__.Square(parseInt(x), parseInt(y));\r\n    clickOnBoard.checkClick(square);\r\n}\r\n\r\nfunction resetClickOnClick(event) {\r\n    const div = event.currentTarget;\r\n    const counter = div.dataset.counter;\r\n    const clickOnBoard = boards[counter];\r\n    clickOnBoard.reset();\r\n}\r\n\r\nclass ClickOnControls {\r\n\r\n    buttonsContainer;\r\n    reset;\r\n\r\n    constructor(container, counter) {\r\n        this.reset = document.createElement(\"button\");\r\n        this.reset.classList.add(\"btn\");\r\n        this.reset.classList.add(\"btn-primary\");\r\n        this.reset.dataset.counter = counter;\r\n        this.reset.appendChild(document.createTextNode(\"Ricomincia\"));\r\n        this.reset.addEventListener('click', resetClickOnClick);\r\n\r\n        const buttonGroup = document.createElement(\"div\");\r\n        buttonGroup.classList.add(\"btn-group\");\r\n        buttonGroup.classList.add(\"btn-group-sm\");\r\n        buttonGroup.setAttribute(\"role\", \"group\");\r\n        buttonGroup.setAttribute(\"aria-label\", \"Gruppo di controlli\");\r\n        buttonGroup.appendChild(this.reset);\r\n\r\n        this.buttonsContainer = document.createElement(\"div\");\r\n        this.buttonsContainer.classList.add(\"text-center\");\r\n        this.buttonsContainer.appendChild(buttonGroup);\r\n\r\n        container.appendChild(this.buttonsContainer);\r\n    }\r\n\r\n}\r\n\r\nclass FreeGameBoard {\r\n\r\n    container;\r\n    counter;\r\n\r\n    position;\r\n    board;\r\n    score;\r\n\r\n    constructor(container, counter) {\r\n        this.container = container;\r\n        this.counter = counter;\r\n\r\n        this.position = _position_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStartingPosition();\r\n        this.board = new _board_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](container, counter, freeGameBoardOnClick)\r\n        this.board.setPosition(this.position);\r\n        this.score = new _score_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](container, this.board);\r\n        this.score.takeScore(this.position);\r\n    }\r\n\r\n}\r\n\r\nfunction freeGameBoardOnClick(event) {\r\n    // Ignore if we're still animating the last move.\r\n    if (_board_js__WEBPACK_IMPORTED_MODULE_1__.animatingFlip) {\r\n        return;\r\n    }\r\n\r\n    // Find the coordinates of the clicked square.\r\n    const div = event.currentTarget;\r\n    const {counter, x, y} = div.dataset;  // NOTE: strings, not ints\r\n    const freeGameBoard = boards[counter];\r\n    const square = new _position_js__WEBPACK_IMPORTED_MODULE_0__.Square(parseInt(x), parseInt(y));\r\n    const nextPosition = freeGameBoard.position.playStone(square);\r\n    // If the play was valid, update the score.\r\n    if (nextPosition != null) {\r\n        freeGameBoard.position = nextPosition;\r\n        freeGameBoard.board.playPosition(freeGameBoard.position);\r\n        freeGameBoard.score.takeScore(freeGameBoard.position);\r\n    }\r\n}\r\n\r\nclass MatchFileBoard {\r\n\r\n    currentPosition;\r\n    board;\r\n    score;\r\n    controls;\r\n    comment;\r\n\r\n    constructor(container, counter) {\r\n        this.currentPosition = _position_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getEmptyPosition();\r\n        this.board = new _board_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](container, counter, staticBoardOnClick);\r\n        this.board.setPosition(this.currentPosition);\r\n        this.score = new _score_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](container, this.board);\r\n        this.score.takeScore(this.currentPosition);\r\n        this.controls = new MatchControls(container, counter);\r\n        this.comment = new PositionComment(container);\r\n\r\n        const matchFile = container.dataset['file'];\r\n        let json;\r\n        fetch(matchFile)\r\n            .then((response) => response.json())\r\n            .then((json) => this.readMatch(json));\r\n    }\r\n\r\n    readMatch(json) {\r\n        this.currentPosition = _position_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getPositionFromJSON(json);\r\n        this.currentPosition.comment = json.comment;\r\n        var curPosition = this.currentPosition;\r\n        if (json.moves != null) {\r\n            json.moves.forEach((move) => {\r\n                const square = _position_js__WEBPACK_IMPORTED_MODULE_0__.Square.fromString(move.move);\r\n                curPosition = curPosition.playStone(square);\r\n                curPosition.comment = move.comment;\r\n            });\r\n            if (json.moves.length < 2) {\r\n                this.controls.prev.remove();\r\n                this.controls.last.remove();\r\n            }\r\n        }\r\n        else {\r\n            this.controls.buttonsContainer.remove();\r\n        }\r\n        if (json.controls != null) {\r\n            if (!json.controls.previous) {\r\n                this.controls.prev.remove();\r\n            }\r\n            if (!json.controls.last) {\r\n                this.controls.last.remove();\r\n            }\r\n            if (!json.controls.score) {\r\n                this.score.scoreContainer.remove();\r\n            }\r\n            if (!json.controls.turn) {\r\n                this.score.turnContainer.remove();\r\n            }\r\n        }\r\n        this.board.setPosition(this.currentPosition);\r\n        this.score.takeScore(this.currentPosition);\r\n        this.controls.update(this.currentPosition);\r\n        this.comment.setPositionComment(this.currentPosition);\r\n\r\n        if (json.add != null) {\r\n            if (json.add[\"a-squares\"]) {\r\n                this.board.addASquares();\r\n            }\r\n            if (json.add[\"b-squares\"]) {\r\n                this.board.addBSquares();\r\n            }\r\n            if (json.add[\"c-squares\"]) {\r\n                this.board.addCSquares();\r\n            }\r\n            if (json.add[\"x-squares\"]) {\r\n                this.board.addXSquares();\r\n            }\r\n            if (json.add[\"squares\"] != null) {\r\n                json.add.squares.forEach((entry) => {\r\n                    const square = _position_js__WEBPACK_IMPORTED_MODULE_0__.Square.fromString(entry.square);\r\n                    this.board.addLetter(square.x, square.y, entry.value);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nclass MatchControls {\r\n\r\n    buttonsContainer;\r\n    first;\r\n    prev;\r\n    next;\r\n    last;\r\n\r\n    constructor(container, counter) {\r\n        this.first = document.createElement(\"button\");\r\n        this.first.classList.add(\"btn\");\r\n        this.first.classList.add(\"btn-primary\");\r\n        this.first.dataset.counter = counter;\r\n        this.first.appendChild(document.createTextNode(\"|<\"));\r\n        this.first.addEventListener('click', matchOnFirstClick);\r\n\r\n        this.prev = document.createElement(\"button\");\r\n        this.prev.classList.add(\"btn\");\r\n        this.prev.classList.add(\"btn-primary\");\r\n        this.prev.dataset.counter = counter;\r\n        this.prev.appendChild(document.createTextNode(\"<\"));\r\n        this.prev.addEventListener('click', matchOnPrevClick);\r\n\r\n        this.next = document.createElement(\"button\");\r\n        this.next.classList.add(\"btn\");\r\n        this.next.classList.add(\"btn-primary\");\r\n        this.next.dataset.counter = counter;\r\n        this.next.appendChild(document.createTextNode(\">\"));\r\n        this.next.addEventListener('click', matchOnNextClick);\r\n\r\n        this.last = document.createElement(\"button\");\r\n        this.last.classList.add(\"btn\");\r\n        this.last.classList.add(\"btn-primary\");\r\n        this.last.dataset.counter = counter;\r\n        this.last.appendChild(document.createTextNode(\">|\"));\r\n        this.last.addEventListener('click', matchOnEndClick);\r\n\r\n        const buttonGroup = document.createElement(\"div\");\r\n        buttonGroup.classList.add(\"btn-group\");\r\n        buttonGroup.classList.add(\"btn-group-sm\");\r\n        buttonGroup.setAttribute(\"role\", \"group\");\r\n        buttonGroup.setAttribute(\"aria-label\", \"Gruppo di controlli\");\r\n        buttonGroup.appendChild(this.first);\r\n        buttonGroup.appendChild(this.prev);\r\n        buttonGroup.appendChild(this.next);\r\n        buttonGroup.appendChild(this.last);\r\n\r\n        this.buttonsContainer = document.createElement(\"div\");\r\n        this.buttonsContainer.classList.add(\"text-center\");\r\n        this.buttonsContainer.appendChild(buttonGroup);\r\n\r\n        container.appendChild(this.buttonsContainer);\r\n    }\r\n\r\n    update(position) {\r\n        this.first.disabled = (position.prevPosition == null);\r\n        this.prev.disabled = (position.prevPosition == null);\r\n        this.next.disabled = (position.nextPosition == null);\r\n        this.last.disabled = (position.nextPosition == null);\r\n    }\r\n\r\n}\r\n\r\nclass PositionComment {\r\n\r\n    div;\r\n\r\n    constructor(container) {\r\n        this.div = document.createElement(\"div\");\r\n        this.div.classList.add('text-center');\r\n        container.appendChild(this.div)\r\n    }\r\n\r\n    setComment(comment) {\r\n        if (comment == null) {\r\n            this.div.innerHTML = \"\";\r\n        }\r\n        else {\r\n            this.div.innerHTML = comment;\r\n        }\r\n    }\r\n\r\n    setPositionComment(position) {\r\n        if (position.comment == null) {\r\n            this.div.innerHTML = \"\";\r\n        }\r\n        else {\r\n            this.div.innerHTML = position.comment;\r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction matchOnNextClick(event) {\r\n    const div = event.currentTarget;\r\n    const counter = div.dataset.counter;\r\n    const matchFileBoard = boards[counter];\r\n    const nextPosition = matchFileBoard.currentPosition.nextPosition;\r\n    if (nextPosition != null) {\r\n        matchFileBoard.board.playPosition(nextPosition);\r\n        matchFileBoard.score.takeScore(nextPosition);\r\n        matchFileBoard.comment.setPositionComment(nextPosition);\r\n        matchFileBoard.controls.update(nextPosition);\r\n        matchFileBoard.currentPosition = nextPosition;\r\n    }\r\n}\r\n\r\nfunction matchOnPrevClick(event) {\r\n    const div = event.currentTarget;\r\n    const counter = div.dataset.counter;\r\n    const matchFileBoard = boards[counter];\r\n    const prevPosition = matchFileBoard.currentPosition.prevPosition;\r\n    if (prevPosition != null) {\r\n        matchFileBoard.board.setPosition(prevPosition);\r\n        matchFileBoard.score.takeScore(prevPosition);\r\n        matchFileBoard.comment.setPositionComment(prevPosition);\r\n        matchFileBoard.controls.update(prevPosition);\r\n        matchFileBoard.currentPosition = prevPosition;\r\n    }\r\n}\r\n\r\nfunction matchOnFirstClick(event) {\r\n    const div = event.currentTarget;\r\n    const counter = div.dataset.counter;\r\n    const matchFileBoard = boards[counter];\r\n    var curPosition = matchFileBoard.currentPosition;\r\n    var prevPosition = curPosition.prevPosition;\r\n    if (prevPosition != null) {\r\n        while (prevPosition != null) {\r\n            curPosition = prevPosition;\r\n            prevPosition = curPosition.prevPosition;\r\n        }\r\n        matchFileBoard.board.setPosition(curPosition);\r\n        matchFileBoard.score.takeScore(curPosition);\r\n        matchFileBoard.comment.setPositionComment(curPosition);\r\n        matchFileBoard.controls.update(curPosition);\r\n        matchFileBoard.currentPosition = curPosition;\r\n    }\r\n}\r\n\r\nfunction matchOnEndClick(event) {\r\n    const div = event.currentTarget;\r\n    const counter = div.dataset.counter;\r\n    const matchFileBoard = boards[counter];\r\n    var curPosition = matchFileBoard.currentPosition;\r\n    if (curPosition.nextPosition != null) {\r\n        while (curPosition.nextPosition != null) {\r\n            curPosition = curPosition.nextPosition;\r\n        }\r\n        matchFileBoard.board.setPosition(curPosition);\r\n        matchFileBoard.score.takeScore(curPosition);\r\n        matchFileBoard.comment.setPositionComment(curPosition);\r\n        matchFileBoard.controls.update(curPosition);\r\n        matchFileBoard.currentPosition = curPosition;\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./src/js/othello.js?");

/***/ }),

/***/ "./src/js/position.js":
/*!****************************!*\
  !*** ./src/js/position.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BLACK: () => (/* binding */ BLACK),\n/* harmony export */   EMPTY: () => (/* binding */ EMPTY),\n/* harmony export */   Square: () => (/* binding */ Square),\n/* harmony export */   WHITE: () => (/* binding */ WHITE),\n/* harmony export */   \"default\": () => (/* binding */ Position),\n/* harmony export */   getStartingPosition: () => (/* binding */ getStartingPosition)\n/* harmony export */ });\nconst EMPTY = 0;\r\nconst WHITE = 1;\r\nconst BLACK = -1;\r\n\r\nconst LETTERS = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\r\nconst NUMBERS = ['1', '2', '3', '4', '5', '6', '7', '8']\r\n\r\nconst FROM_LETTERS = {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6, 'H': 7}\r\nconst FROM_NUMBERS = {'1': 0, '2': 1, '3': 2, '4': 3, '5': 4, '6': 5, '7': 6, '8': 7}\r\n\r\nfunction getStartingPosition() {\r\n    const grid = [];\r\n    for (let x = 0; x < 8; x++) {\r\n        const row = [];\r\n        grid.push(row);\r\n        for (let y = 0; y < 8; y++) {\r\n            row.push(EMPTY);\r\n        }\r\n    }\r\n    grid[3][3] = WHITE;\r\n    grid[4][4] = WHITE;\r\n    grid[3][4] = BLACK;\r\n    grid[4][3] = BLACK;\r\n    const turn = BLACK;\r\n    return new Position(grid, turn)\r\n}\r\n\r\nclass Position {\r\n\r\n    grid;\r\n    turn;\r\n    comment;\r\n    played;\r\n    flipped;\r\n    gameOver;\r\n    passCount;\r\n    nextPosition;\r\n    prevPosition;\r\n\r\n    constructor(grid, turn) {\r\n        this.grid = grid;\r\n        this.turn = turn;\r\n        this.gameOver = false;\r\n        this.passCount = 0;\r\n        // TODO: controllare se il turno è valido e se la partita è finita\r\n        this.checkValidMoves();\r\n        this.comment = null;\r\n    }\r\n\r\n    static getEmptyPosition() {\r\n        const grid = [];\r\n        for (let x = 0; x < 8; x++) {\r\n            const row = [];\r\n            grid.push(row);\r\n            for (let y = 0; y < 8; y++) {\r\n                row.push(EMPTY);\r\n            }\r\n        }\r\n        const turn = BLACK;\r\n        return new Position(grid, turn)\r\n    }\r\n\r\n    static getStartingPosition() {\r\n        const grid = [];\r\n        for (let x = 0; x < 8; x++) {\r\n            const row = [];\r\n            grid.push(row);\r\n            for (let y = 0; y < 8; y++) {\r\n                row.push(EMPTY);\r\n            }\r\n        }\r\n        grid[3][3] = WHITE;\r\n        grid[4][4] = WHITE;\r\n        grid[3][4] = BLACK;\r\n        grid[4][3] = BLACK;\r\n        const turn = BLACK;\r\n        return new Position(grid, turn)\r\n    }\r\n\r\n    static getPositionFromDataset(container) {\r\n        if (container.dataset.hasOwnProperty('r1')) {\r\n            const grid = [];\r\n            for (let x = 0; x < 8; x++) {\r\n                const row = [];\r\n                grid.push(row);\r\n                const row_data = container.dataset['r' + (x + 1).toString()];\r\n                for (let y = 0; y < 8; y++) {\r\n                    const cell_data = row_data.charAt(y);\r\n                    if (cell_data == '#') {\r\n                        row.push(BLACK);\r\n                    }\r\n                    else if (cell_data == 'O') {\r\n                        row.push(WHITE);\r\n                    }\r\n                    else {\r\n                        row.push(EMPTY);\r\n                    }\r\n                }\r\n            }\r\n            let turn;\r\n            if (container.dataset.hasOwnProperty('turn')) {\r\n                if (container.dataset['turn'] == 'white') {\r\n                    turn = WHITE;\r\n                }\r\n                else {\r\n                    turn = BLACK;\r\n                }\r\n            }\r\n            else {\r\n                turn = BLACK;\r\n            }\r\n            return new Position(grid, turn);\r\n        }\r\n        else {\r\n            return Position.getStartingPosition();\r\n        }\r\n    }\r\n\r\n    static getPositionFromJSON(json) {\r\n        var position;\r\n        if (json.position != null) {\r\n            const grid = [];\r\n            for (let x = 0; x < 8; x++) {\r\n                const row = [];\r\n                grid.push(row);\r\n                const row_data = json.position[x];\r\n                for (let y = 0; y < 8; y++) {\r\n                    const cell_data = row_data.charAt(y);\r\n                    if (cell_data == '#') {\r\n                        row.push(BLACK);\r\n                    }\r\n                    else if (cell_data == 'O') {\r\n                        row.push(WHITE);\r\n                    }\r\n                    else {\r\n                        row.push(EMPTY);\r\n                    }\r\n                }\r\n            }\r\n            let turn;\r\n            if (json.turn != null) {\r\n                if (json.turn == 'white') {\r\n                    turn = WHITE;\r\n                }\r\n                else {\r\n                    turn = BLACK;\r\n                }\r\n            }\r\n            else {\r\n                turn = BLACK;\r\n            }\r\n            position = new Position(grid, turn);\r\n        }\r\n        else {\r\n            position = Position.getStartingPosition();\r\n        }\r\n        return position;\r\n    }\r\n\r\n    countStones() {\r\n        const scores = { black: 0, white: 0 };\r\n\r\n        for (let y = 0; y < 8; ++y) {\r\n            for (let x = 0; x < 8; ++x) {\r\n                if (this.grid[y][x] == BLACK) {\r\n                    scores.black += 1;\r\n                }\r\n\r\n                if (this.grid[y][x] == WHITE) {\r\n                    scores.white += 1;\r\n                }\r\n            }\r\n        }\r\n        return scores;\r\n    }\r\n\r\n    checkValidMoves() {\r\n        const scores = this.countStones();\r\n\r\n        // If someone is out of pieces, the game is over.\r\n        if (scores.black == 0 || scores.white == 0) {\r\n            this.gameOver = true;\r\n            return;\r\n        }\r\n\r\n        // If both players had to pass, nobody can move and the game is over.\r\n        if (this.passCount >= 2) {\r\n            this.gameOver = true;\r\n            return;\r\n        }\r\n\r\n        const foundAValidMove = this.findAValidMove()\r\n\r\n        // If there are no valid moves, then the current player must pass.\r\n        if (foundAValidMove) {\r\n            this.passCount = 0;\r\n        } else {\r\n            this.passCount++;\r\n            this.onPass();\r\n        }\r\n    }\r\n\r\n    findAValidMove() {\r\n        // Find and mark all the valid moves in the game board.\r\n        for (let y = 0; y < 8; ++y) {\r\n            for (let x = 0; x < 8; ++x) {\r\n                if (this.isValidPlay(x, y)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    onPass() {\r\n        this.turn *= -1;\r\n        this.checkValidMoves();\r\n    }\r\n\r\n    playStone(square) {\r\n        const x = square.x;\r\n        const y = square.y;\r\n        // Don't play if game is over.\r\n        if (this.gameOver) {\r\n            return null;\r\n        }\r\n\r\n        // Don't play if the move is invalid.\r\n        if (!this.isValidPlay(x, y)) {\r\n            return null;\r\n        }\r\n\r\n        // Copy the grid.\r\n        const nextGrid = this.copyGrid();\r\n\r\n        // Place the stone in the new grid.\r\n        nextGrid[y][x] = this.turn;\r\n\r\n        const flipped = [];\r\n\r\n        // Flip over the opponent's pieces in every valid direction.\r\n        for (const [dx, dy] of Position.allDirections()) {\r\n            if (this.isValidInDirection(x, y, dx, dy)) {\r\n                for (const [nx,ny] of Position.scanDirection(x, y, dx, dy)) {\r\n                    // Stop on your own color.\r\n                    if (this.grid[ny][nx] == this.turn) {\r\n                        break;\r\n                    }\r\n                    nextGrid[ny][nx] = this.turn;\r\n                    flipped.push(new Square(nx, ny));\r\n                }\r\n            }\r\n        }\r\n\r\n        // Change turn; it will be checked by the new position constructor.\r\n        const nextTurn = - this.turn;\r\n\r\n        // Build the next position.\r\n        this.nextPosition = new Position(nextGrid, nextTurn);\r\n        // Save the played position\r\n        this.nextPosition.played = new Square(x, y);\r\n        // Save the flipped stones\r\n        this.nextPosition.flipped = flipped;\r\n        // Link the next position to this one.\r\n        this.nextPosition.prevPosition = this;\r\n\r\n        return this.nextPosition;\r\n    }\r\n\r\n    isValidPlay(x, y) {\r\n        // If it's not empty, it's not a valid play.\r\n        if (this.grid[y][x] != EMPTY) {\r\n            return false;\r\n        }\r\n\r\n        // A valid play at x,y must be able to flip stones in some direction.\r\n        for (const [dx, dy] of Position.allDirections()) {\r\n            if (this.isValidInDirection(x, y, dx, dy)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    copyGrid() {\r\n        const nextGrid = [];\r\n        for (let x = 0; x < 8; x++) {\r\n            const row = [];\r\n            nextGrid.push(row);\r\n            for (let y = 0; y < 8; y++) {\r\n                row.push(this.grid[x][y])\r\n            }\r\n        }\r\n        return nextGrid;\r\n    }\r\n\r\n    isValidInDirection(x, y, dx, dy) {\r\n        let first = true;\r\n\r\n        for (const [nx, ny] of Position.scanDirection(x, y, dx, dy)) {\r\n            // If the first square in direction dx,dy is not the opposite player's,\r\n            // then this is not a valid play based on that direction.\r\n            if (first) {\r\n                if (this.grid[ny][nx] != -this.turn) {\r\n                    return false;\r\n                }\r\n\r\n                first = false;\r\n            }\r\n\r\n            // If the next square is empty, we failed to find another stone in our\r\n            // color, so this is not a valid play based on that direction.\r\n            if (this.grid[ny][nx] == EMPTY) {\r\n                return false;\r\n            }\r\n\r\n            // Once we find a stone of our own color after some number of the\r\n            // opponent's stones, this is a valid play in this direction.\r\n            if (this.grid[ny][nx] == this.turn) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // If we reach the end of the board without finding our own color, this is\r\n        // not a valid play based on that direction.\r\n        return false;\r\n    }\r\n\r\n    // A generator that yields board squares starting at x,y and moving in the\r\n    // direction dx,dy, excluding the starting position at x,y.\r\n    static *scanDirection(x, y, dx, dy) {\r\n        x += dx;\r\n        y += dy;\r\n\r\n        for (; y >= 0 && y <= 7 && x >= 0 && x <= 7; y += dy, x += dx) {\r\n            yield [x, y];\r\n        }\r\n    }\r\n\r\n    static *allDirections() {\r\n        for (const dx of [-1, 0, 1]) {\r\n            for (const dy of [-1, 0, 1]) {\r\n                // Never yield direction [0, 0] (in place)\r\n                if (dx || dy) {\r\n                    yield [dx, dy];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nclass Square {\r\n    x;\r\n    y;\r\n\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    toString() {\r\n        return LETTERS[this.x] + NUMBERS[this.y];\r\n    }\r\n\r\n    static fromString(str) {\r\n        const x = FROM_LETTERS[str.charAt(0)];\r\n        const y = FROM_NUMBERS[str.charAt(1)];\r\n        return new Square(x, y);\r\n    }\r\n\r\n}\n\n//# sourceURL=webpack:///./src/js/position.js?");

/***/ }),

/***/ "./src/js/score.js":
/*!*************************!*\
  !*** ./src/js/score.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Score)\n/* harmony export */ });\n/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ \"./src/js/position.js\");\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./board.js */ \"./src/js/board.js\");\n\r\n\r\n\r\n\r\nclass Score {\r\n\r\n    scoreContainer;\r\n    scoreElements = {};\r\n\r\n    turnContainer;\r\n    turnElement;\r\n\r\n    constructor(container) {\r\n        this.scoreContainer = document.createElement('div');\r\n        this.scoreContainer.classList.add('score-container');\r\n        container.appendChild(this.scoreContainer);\r\n\r\n        // Create the score board.\r\n        this.scoreElements.black = this.createScore('black', this.scoreContainer);\r\n        this.scoreElements.white = this.createScore('white', this.scoreContainer);\r\n        this.createTurnText(container);\r\n    }\r\n\r\n    createTurnText(container) {\r\n        this.turnElement = document.createElement('div');\r\n        this.turnElement.classList.add('turn-text');\r\n        this.turnElement.innerHTML = 'Mossa al nero';\r\n\r\n        this.turnContainer = document.createElement('div');\r\n        this.turnContainer.classList.add('turn-container');\r\n        this.turnContainer.appendChild(this.turnElement);\r\n\r\n        container.appendChild(this.turnContainer);\r\n    }\r\n\r\n    // Create and return score container elements for the given color.\r\n    createScore(color, scoreContainer) {\r\n        // The container for this player's score.\r\n        const span = document.createElement('span');\r\n        span.classList.add('score-wrapper');\r\n        scoreContainer.appendChild(span);\r\n\r\n        // The container for the stone in the score board.\r\n        const stoneContainer = document.createElement('span');\r\n        stoneContainer.classList.add('score-stone-container');\r\n        stoneContainer.classList.add(color);\r\n        span.appendChild(stoneContainer);\r\n\r\n        // The stone itself.\r\n        const stone = (0,_board_js__WEBPACK_IMPORTED_MODULE_1__.createStone)();\r\n        stoneContainer.appendChild(stone);\r\n\r\n        // A span to contain the actual numerical score.\r\n        const scoreSpan = document.createElement('span');\r\n        scoreSpan.classList.add('score-text');\r\n        span.appendChild(scoreSpan);\r\n\r\n        // Return the container and score span.\r\n        return {\r\n            container: stoneContainer,\r\n            scoreSpan,\r\n        };\r\n    }\r\n\r\n    // Count the stones on the board and update the score text.\r\n    takeScore(position) {\r\n        const scores = position.countStones();\r\n\r\n        for (const color in scores) {\r\n            this.scoreElements[color].scoreSpan.textContent = scores[color];\r\n        }\r\n\r\n        if (position.gameOver) {\r\n            this.turnElement.innerHTML = 'Partita terminata';\r\n        }\r\n        else if (position.turn == _position_js__WEBPACK_IMPORTED_MODULE_0__.WHITE) {\r\n            this.turnElement.innerHTML = 'Mossa al bianco';\r\n        }\r\n        else {\r\n            this.turnElement.innerHTML = 'Mossa al nero';\r\n        }\r\n    }\r\n\r\n}\n\n//# sourceURL=webpack:///./src/js/score.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/othello.js");
/******/ 	
/******/ })()
;